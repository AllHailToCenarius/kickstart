extends ../fullpage-layout

block hero-title
  h1 Layout and CSS

block fullPane
  :markdown
    # Fixed, Fluid, and Fluid-Fixed

    Before you start adding components to your page, it's best to decide if
    you want a fixed, fluid, or fixed-fluid layout.

    ## Fixed layout

    A fixed layout simply limits the width of the layout to a certain amount.

  iframe.animation(src="/iframes/layout-fixed/fixed.html")

  :markdown
    Create a container around your content <span class="if-semantic">and use the mixin
    <code>container($fixed: true)</code></span><span class="ifnot-semantic">and
    use the <code>.container-fixed</code> class.

    The default max-width is about 768px, however, you can define your own by adding
    a `max-width` property.

  .if-semantic
    :markdown
      <span>

          <div class="container">
            <h1>Hello world</h1>
          </div>

          .container {
            @include container($fixed: true);
            max-width: 700px;
          }

  .ifnot-semantic
    :markdown
      <span>

          <div class="container fixed">
            <h1>Hello world</h1>
          </div>

  :markdown
    ## Fluid layout

    A fluid layout allows the width of the content to match the width of the viewport

  iframe.animation(src="/iframes/layout-fluid/fluid.html")

  :markdown
    This one is probably the easiest to implement of all, because it is
    default behavior of HTML content. Simply omit the container styling.

    To have elements break out of a container (called "bleeding"), just
    end the container before the bleed content and open it back up afterwards.

    ## Fluid-fixed layout

    This layout is the default behavior for a container in Kickstart and
    combines the best of both worlds.

    Instead of constantly resizing to the size of the viewport, a new fixed
    width is used at each breakpoint.

  iframe.animation(src="/iframes/layout-fluid-fixed/fluid-fixed.html")

  :markdown
    Create a container around your content <span class="if-semantic">and use the mixin
    <code>container()</code></span><span class="ifnot-semantic">and
    use the <code>.container</code> class.

  .if-semantic
    :markdown
      <span>

          <div class="container">
            <h1>Hello world</h1>
          </div>

          .container {
            @include container();
          }

  .ifnot-semantic
    :markdown
      <span>

          <div class="container">
            <h1>Hello world</h1>
          </div>

  :markdown
    # HTML styles

    Several styles are applied at the HTML level for convenience throughout
    the DOM.

    A default font-size of 18px (varies depending on the theme) is set. This
    should really be the only place where `px` are used to define font-size.
    Elsewhere, the `rem` unit is used, which is relative to the font-size in
    the HTML document.

    On supporting browsers, this font-size will scale with the width of the
    screen. See [Typography](/docs/3.x/ui/typography/) for more information
    on responsive text.

    # Naming conventions

    Kickstart is not a fan of [BEM](http://csswizardry.com/2013/01/mindbemding-getting-your-head-round-bem-syntax/)
    for several reasons that won't be mentioned here.

    However, a miniscule part of the philosophy behind it is used in
    Kickstart naming conventions. As an alternative to distinguishing "Blocks,
    elements, and modifiers" Kickstrap simply distinguishes "Components
    and modifiers."

    ## Components

    Components can be HTML elements that are standalone--they cannot or
    typically do not have other components nested within them.

        <button class="button">Send</button>

    Other components can have elements nested within them, but no
    distinction is made in the naming convention.

        <div class="navbar">
          <ul>
            <li>
              <a href="#">Home</a>
            </li>
            <li>
              <a class="button" href="#">Home</a>
            </li>
          </ul>
        </div>

    Component names try to remain simple, however sometimes a space
    character is needed. The underscore (_) character is reserved for this.

        <div class="tooltip_trigger">
          <span class="tooltip"></span>
        </div>

    ## Modifiers

    Elements with alternate states and schemes have **modifiers**

    For example, here is a default button and a yellow button

        <button class="button">...</button>
        <button class="button button-yellow">...</button>

    Why the repetition? Why not just `.button .yellow`? This is to
    specify that yellow is a modifier on the button.

    You may want to define your button as a non-kickstart component
    "foo" as well

        <button class="button foo button-yellow">...</button>

    Maybe foo is a component that styles the outline of the button,
    which we want to be blue.

        <button class="button foo button-yellow foo-blue">...</button>

    With this convention, it's clear where the modifier should be
    applied.

  div(style="display: none")
    :markdown
      # Root Element

      The concept of the root element in Kickstart is what would be
      left if we combined the styling from all elements, only leaving
      the things all of them had in common.

      The end result of this doesn't fit the definition perfectly, but
      it comes close and gives us a useful tool for sharing an aesthetic.

      In the default theme of Kickstart, the root-element has a specific
      top and bottom padding, border radius, and font rules.

      Here it is with some shading for clarity.

    .example
      .root-element(style="background:rgba(0, 0, 0, 0.2)") foo

    :markdown
      This very simple piece of UI can be shared by many components. It
      also gets us closer to a guarantee that any variety of many different
      elements will fit nicely together.

      ## Mixins

      This is also how Kickstart defines its mixins and parameters.
      The goal of defining this is to maintain consistency across mixins as
      much as possible.

          @mixin root-element($background-color, $color)

      Some properties, like `$color` seem to stand for CSS
      properties. This is why the mixin uses those names instead of
      `$foreground-color`. However, there are often other accessory
      styles that come in with it. (For example, the navbar uses lighter
      text when it's given a darker background.)

  :markdown
    # Colors
    ## Rainbow colors

    To use a color variable, refer to the `$color` Sass map and retrieve one of red, orange, yellow, green, blue, or violet.

        .button
          color: map-get($colors, red)

    [Read more about Sass maps](http://sass-lang.com/documentation/file.SASS_REFERENCE.html#maps)

    ##Grayscale

    Grayscale variables live in three separate maps, `$white`, `$gray`, and `$black`.
    Shades of each are called using `-`, `-er`, and `-est` patterns as such:

        map-get($white, darker)

    For the $gray map, you can retrieve the light, lighter, and lightest light subsets or the
    dark, darker, and darkest dark subsets.

        map-get($gray, lightest)
        map-get($gray, lighter)
        map-get($gray, light)
        map-get($gray, dark)
        map-get($gray, darker)
        map-get($gray, darkest)

    The same is true for `$white` and `$black`. Intuitively, "light" versions of `$white` do
    not exist, nor do "dark" versions of `$black`

        map-get($white, dark)
        map-get($white, darker)
        map-get($white, darkest)

        map-get($gray, lightest)
        map-get($gray, lighter)
        map-get($gray, light)
        map-get($gray, dark)
        map-get($gray, darker)
        map-get($gray, darkest)

        map-get($black, lightest)
        map-get($black, lighter)
        map-get($black, light)

    For regular white, gray, and black, simply use the css name.

        white

        map-get($white, dark)
        map-get($white, darker)
        map-get($white, darkest)

        map-get($gray, lightest)
        map-get($gray, lighter)
        map-get($gray, light)

        gray

        map-get($gray, dark)
        map-get($gray, darker)
        map-get($gray, darkest)

        map-get($black, lightest)
        map-get($black, lighter)
        map-get($black, light)

        black

    The above is the full grayscale set from light to dark.

    ## Semantic colors

    Two semantic colors, `$primary-color` and `$secondary-color` are assigned to the colors/grayscale 
    values above via the chosen theme. These are used throughout Kickstart to denote hierarchy in the
    interface.
